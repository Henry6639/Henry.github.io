<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原生JavaScript 俄罗斯方块</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
        }

        body {
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }

        /* 游戏画布（网格）样式 */
        #tetris {
            border: 3px solid #333;
            background-color: #000;
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(20, 30px);
            gap: 1px;
        }

        /* 网格单元格样式 */
        .cell {
            width: 30px;
            height: 30px;
            background-color: #1a1a1a;
        }

        /* 方块填充样式（不同形状不同颜色） */
        .cell.I {
            background-color: #00ffff; /* 青色 */
        }

        .cell.J {
            background-color: #0000ff; /* 蓝色 */
        }

        .cell.L {
            background-color: #ffa500; /* 橙色 */
        }

        .cell.O {
            background-color: #ffff00; /* 黄色 */
        }

        .cell.S {
            background-color: #00ff00; /* 绿色 */
        }

        .cell.T {
            background-color: #800080; /* 紫色 */
        }

        .cell.Z {
            background-color: #ff0000; /* 红色 */
        }

        /* 游戏信息面板样式 */
        .game-info {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }

        .game-info h2 {
            margin-bottom: 20px;
            text-align: center;
            color: #333;
        }

        .info-item {
            margin: 15px 0;
            font-size: 18px;
            color: #555;
        }

        .info-item span {
            font-weight: bold;
            color: #000;
        }

        .control-tips {
            margin-top: 30px;
            font-size: 14px;
            color: #666;
            line-height: 1.6;
        }

        /* 开始/重置按钮样式 */
        #gameBtn {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 18px;
            background-color: #2196f3;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #gameBtn:hover {
            background-color: #1976d2;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- 游戏网格容器 -->
        <div id="tetris"></div>

        <!-- 游戏信息面板 -->
        <div class="game-info">
            <h2>俄罗斯方块</h2>
            <div class="info-item">当前得分: <span id="score">0</span></div>
            <div class="info-item">已消行数: <span id="lines">0</span></div>
            <div class="info-item">游戏状态: <span id="status">未开始</span></div>
            <button id="gameBtn">开始游戏</button>
            <div class="control-tips">
                操作说明：<br>
                ← 左移 | → 右移 | ↓ 加速下落<br>
                ↑ 旋转方块 | 空格 直接落底
            </div>
        </div>
    </div>

    <script>
        // 1. 游戏核心配置与全局变量
        const COLS = 10; // 网格列数
        const ROWS = 20; // 网格行数
        const tetris = document.getElementById('tetris');
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const statusElement = document.getElementById('status');
        const gameBtn = document.getElementById('gameBtn');

        let grid = []; // 游戏网格数据（二维数组）
        let currentPiece = null; // 当前下落的方块
        let currentX = 0; // 当前方块的X坐标
        let currentY = 0; // 当前方块的Y坐标
        let score = 0; // 当前得分
        let lines = 0; // 已消行数
        let gameInterval = null; // 游戏定时器
        let gameRunning = false; // 游戏运行状态

        // 2. 定义所有俄罗斯方块形状（7种基础形状，包含旋转状态）
        // 每个形状用二维数组表示，1表示方块存在，0表示空白
        const TETROMINOS = {
            I: {
                shape: [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                color: 'I'
            },
            J: {
                shape: [
                    [1, 0, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: 'J'
            },
            L: {
                shape: [
                    [0, 0, 1],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: 'L'
            },
            O: {
                shape: [
                    [1, 1],
                    [1, 1]
                ],
                color: 'O'
            },
            S: {
                shape: [
                    [0, 1, 1],
                    [1, 1, 0],
                    [0, 0, 0]
                ],
                color: 'S'
            },
            T: {
                shape: [
                    [0, 1, 0],
                    [1, 1, 1],
                    [0, 0, 0]
                ],
                color: 'T'
            },
            Z: {
                shape: [
                    [1, 1, 0],
                    [0, 1, 1],
                    [0, 0, 0]
                ],
                color: 'Z'
            }
        };

        // 3. 初始化游戏网格（DOM结构 + 数据结构）
        function initGrid() {
            // 清空网格DOM
            tetris.innerHTML = '';
            // 初始化二维数组数据
            grid = [];
            for (let y = 0; y < ROWS; y++) {
                grid[y] = [];
                for (let x = 0; x < COLS; x++) {
                    grid[y][x] = null; // null表示该位置无方块
                    // 创建网格单元格DOM
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    tetris.appendChild(cell);
                }
            }
        }

        // 4. 随机生成一个新的方块
        function generateRandomPiece() {
            const keys = Object.keys(TETROMINOS);
            const randomKey = keys[Math.floor(Math.random() * keys.length)];
            const tetromino = TETROMINOS[randomKey];
            return {
                shape: JSON.parse(JSON.stringify(tetromino.shape)), // 深拷贝避免修改原数据
                color: tetromino.color
            };
        }

        // 5. 生成新的当前方块并初始化位置
        function spawnNewPiece() {
            currentPiece = generateRandomPiece();
            // 初始化方块位置（水平居中，垂直顶部）
            currentX = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
            currentY = 0;

            // 检查是否生成方块时就碰撞（游戏结束条件）
            if (checkCollision(currentX, currentY, currentPiece.shape)) {
                gameOver();
                return;
            }

            // 渲染新方块
            render();
        }

        // 6. 碰撞检测（判断方块移动/旋转后是否超出边界或与已有方块重叠）
        function checkCollision(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const newX = x + col;
                        const newY = y + row;
                        // 检查是否超出左右边界、下边界，或与已有方块重叠
                        if (
                            newX < 0 || newX >= COLS ||
                            newY >= ROWS ||
                            (newY >= 0 && grid[newY][newX] !== null)
                        ) {
                            return true; // 发生碰撞
                        }
                    }
                }
            }
            return false; // 无碰撞
        }

        // 7. 渲染游戏画面（更新网格DOM显示）
        function render() {
            // 第一步：清空所有单元格的颜色类
            document.querySelectorAll('.cell').forEach(cell => {
                cell.className = 'cell';
            });

            // 第二步：渲染已固定在网格中的方块
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x]) {
                        const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                        if (cell) cell.classList.add('cell', grid[y][x]);
                    }
                }
            }

            // 第三步：渲染当前下落的方块
            if (currentPiece) {
                for (let row = 0; row < currentPiece.shape.length; row++) {
                    for (let col = 0; col < currentPiece.shape[row].length; col++) {
                        if (currentPiece.shape[row][col]) {
                            const x = currentX + col;
                            const y = currentY + row;
                            if (y >= 0 && x >= 0 && x < COLS && y < ROWS) {
                                const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
                                if (cell) cell.classList.add('cell', currentPiece.color);
                            }
                        }
                    }
                }
            }
        }

        // 8. 旋转当前方块（矩阵旋转）
        function rotatePiece() {
            if (!currentPiece || !gameRunning) return;

            // 生成旋转后的形状（矩阵转置 + 反转每行）
            const rotatedShape = currentPiece.shape[0].map((_, index) =>
                currentPiece.shape.map(row => row[index]).reverse()
            );

            // 旋转后可能碰撞，尝试微调位置（墙踢机制，简单版）
            let offsetX = 0;
            if (checkCollision(currentX, currentY, rotatedShape)) {
                // 右移尝试
                if (checkCollision(currentX + 1, currentY, rotatedShape)) {
                    // 左移尝试
                    offsetX = -1;
                } else {
                    offsetX = 1;
                }
            }

            // 若微调后无碰撞，则更新方块形状
            if (!checkCollision(currentX + offsetX, currentY, rotatedShape)) {
                currentX += offsetX;
                currentPiece.shape = rotatedShape;
                render();
            }
        }

        // 9. 移动当前方块
        function movePiece(dx, dy) {
            if (!currentPiece || !gameRunning) return;

            // 检查移动后是否碰撞
            if (!checkCollision(currentX + dx, currentY + dy, currentPiece.shape)) {
                currentX += dx;
                currentY += dy;
                render();
                return true;
            }

            // 垂直移动碰撞（说明方块落地，需要固定到网格）
            if (dy > 0) {
                lockPiece();
                return false;
            }

            return false;
        }

        // 10. 将当前方块固定到游戏网格中
        function lockPiece() {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        const x = currentX + col;
                        const y = currentY + row;
                        if (y >= 0) {
                            grid[y][x] = currentPiece.color;
                        }
                    }
                }
            }

            // 检查并消除满行
            clearCompletedLines();

            // 生成新的方块
            spawnNewPiece();
        }

        // 11. 检查并消除满行
        function clearCompletedLines() {
            let clearedLines = 0;

            for (let y = ROWS - 1; y >= 0; y--) {
                // 判断当前行是否已满
                const isLineComplete = grid[y].every(cell => cell !== null);

                if (isLineComplete) {
                    // 移除当前行并在顶部插入新的空行
                    grid.splice(y, 1);
                    grid.unshift(Array(COLS).fill(null));
                    // 行数回退（因为删除了一行，网格数据上移了）
                    y++;
                    // 统计消行数
                    clearedLines++;
                }
            }

            // 更新得分和消行统计（消行越多，得分越高）
            if (clearedLines > 0) {
                lines += clearedLines;
                // 得分规则：1行100分，2行300分，3行500分，4行800分
                const scoreMap = [0, 100, 300, 500, 800];
                score += scoreMap[clearedLines];
                
                // 更新DOM显示
                scoreElement.textContent = score;
                linesElement.textContent = lines;
            }
        }

        // 12. 方块直接落底
        function hardDrop() {
            if (!currentPiece || !gameRunning) return;

            // 不断向下移动直到碰撞
            while (movePiece(0, 1)) {}
        }

        // 13. 游戏主循环（控制方块自动下落）
        function gameLoop() {
            movePiece(0, 1);
        }

        // 14. 开始游戏
        function startGame() {
            // 重置游戏状态
            score = 0;
            lines = 0;
            scoreElement.textContent = score;
            linesElement.textContent = lines;
            statusElement.textContent = '运行中';
            gameRunning = true;

            // 初始化网格
            initGrid();

            // 生成第一个方块
            spawnNewPiece();

            // 启动游戏定时器（每500毫秒下落一格，可调整速度）
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, 500);

            // 更新按钮状态
            gameBtn.textContent = '重置游戏';
        }

        // 15. 游戏结束
        function gameOver() {
            gameRunning = false;
            clearInterval(gameInterval);
            statusElement.textContent = '游戏结束';
            alert(`游戏结束！\n最终得分：${score}\n已消行数：${lines}`);
        }

        // 16. 停止游戏（重置状态）
        function stopGame() {
            gameRunning = false;
            clearInterval(gameInterval);
            initGrid();
            score = 0;
            lines = 0;
            scoreElement.textContent = score;
            linesElement.textContent = lines;
            statusElement.textContent = '未开始';
            gameBtn.textContent = '开始游戏';
        }

        // 17. 键盘事件监听（控制游戏操作）
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            switch (e.key) {
                case 'ArrowLeft': // 左移
                    movePiece(-1, 0);
                    break;
                case 'ArrowRight': // 右移
                    movePiece(1, 0);
                    break;
                case 'ArrowDown': // 加速下落
                    movePiece(0, 1);
                    break;
                case 'ArrowUp': // 旋转
                    rotatePiece();
                    break;
                case ' ': // 空格直接落底（阻止默认滚动行为）
                    e.preventDefault();
                    hardDrop();
                    break;
            }
        });

        // 18. 按钮点击事件监听
        gameBtn.addEventListener('click', () => {
            if (gameRunning) {
                stopGame();
            } else {
                startGame();
            }
        });

        // 页面加载完成后初始化网格
        window.addEventListener('load', initGrid);
    </script>
</body>
</html>